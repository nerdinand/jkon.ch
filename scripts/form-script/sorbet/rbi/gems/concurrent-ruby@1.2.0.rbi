# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `concurrent-ruby` gem.
# Please instead update this file by running `bin/tapioca gem concurrent-ruby`.

# {include:file:README.md}
#
# source://concurrent-ruby//lib/concurrent-ruby/concurrent/constants.rb#1
module Concurrent
  extend ::Concurrent::Utility::EngineDetector
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/map.rb#7
module Concurrent::Collection; end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/map.rb#10
Concurrent::Collection::MapImplementation = Concurrent::Collection::MriMapBackend

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/mri_map_backend.rb#10
class Concurrent::Collection::MriMapBackend < ::Concurrent::Collection::NonConcurrentMapBackend
  # @return [MriMapBackend] a new instance of MriMapBackend
  #
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/mri_map_backend.rb#12
  def initialize(options = T.unsafe(nil)); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/mri_map_backend.rb#17
  def []=(key, value); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/mri_map_backend.rb#61
  def clear; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/mri_map_backend.rb#33
  def compute(key); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/mri_map_backend.rb#21
  def compute_if_absent(key); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/mri_map_backend.rb#29
  def compute_if_present(key); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/mri_map_backend.rb#53
  def delete(key); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/mri_map_backend.rb#57
  def delete_pair(key, value); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/mri_map_backend.rb#49
  def get_and_set(key, value); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/mri_map_backend.rb#37
  def merge_pair(key, value); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/mri_map_backend.rb#45
  def replace_if_exists(key, new_value); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/mri_map_backend.rb#41
  def replace_pair(key, old_value, new_value); end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/non_concurrent_map_backend.rb#9
class Concurrent::Collection::NonConcurrentMapBackend
  # WARNING: all public methods of the class must operate on the @backend
  # directly without calling each other. This is important because of the
  # SynchronizedMapBackend which uses a non-reentrant mutex for performance
  # reasons.
  #
  # @return [NonConcurrentMapBackend] a new instance of NonConcurrentMapBackend
  #
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/non_concurrent_map_backend.rb#15
  def initialize(options = T.unsafe(nil)); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/non_concurrent_map_backend.rb#19
  def [](key); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/non_concurrent_map_backend.rb#23
  def []=(key, value); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/non_concurrent_map_backend.rb#92
  def clear; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/non_concurrent_map_backend.rb#57
  def compute(key); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/non_concurrent_map_backend.rb#27
  def compute_if_absent(key); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/non_concurrent_map_backend.rb#51
  def compute_if_present(key); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/non_concurrent_map_backend.rb#79
  def delete(key); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/non_concurrent_map_backend.rb#83
  def delete_pair(key, value); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/non_concurrent_map_backend.rb#97
  def each_pair; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/non_concurrent_map_backend.rb#69
  def get_and_set(key, value); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/non_concurrent_map_backend.rb#108
  def get_or_default(key, default_value); end

  # @return [Boolean]
  #
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/non_concurrent_map_backend.rb#75
  def key?(key); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/non_concurrent_map_backend.rb#61
  def merge_pair(key, value); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/non_concurrent_map_backend.rb#44
  def replace_if_exists(key, new_value); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/non_concurrent_map_backend.rb#35
  def replace_pair(key, old_value, new_value); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/non_concurrent_map_backend.rb#104
  def size; end

  private

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/non_concurrent_map_backend.rb#19
  def _get(key); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/non_concurrent_map_backend.rb#23
  def _set(key, value); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/non_concurrent_map_backend.rb#122
  def dupped_backend; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/non_concurrent_map_backend.rb#116
  def initialize_copy(other); end

  # @return [Boolean]
  #
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/non_concurrent_map_backend.rb#126
  def pair?(key, expected_value); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/non_concurrent_map_backend.rb#130
  def store_computed_value(key, new_value); end
end

# `Concurrent::Map` is a hash-like object and should have much better performance
# characteristics, especially under high concurrency, than `Concurrent::Hash`.
# However, `Concurrent::Map `is not strictly semantically equivalent to a ruby `Hash`
# -- for instance, it does not necessarily retain ordering by insertion time as `Hash`
# does. For most uses it should do fine though, and we recommend you consider
# `Concurrent::Map` instead of `Concurrent::Hash` for your concurrency-safe hash needs.
#
# source://concurrent-ruby//lib/concurrent-ruby/concurrent/map.rb#39
class Concurrent::Map < ::Concurrent::Collection::MriMapBackend
  # @return [Map] a new instance of Map
  #
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/map.rb#123
  def initialize(options = T.unsafe(nil), &block); end

  # Get a value with key
  #
  # @param key [Object]
  # @return [Object] the value
  #
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/map.rb#137
  def [](key); end

  # Set a value with key
  #
  # @param key [Object]
  # @param value [Object]
  # @return [Object] the new value
  #
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/map.rb#155
  def []=(key, value); end

  # Iterates over each key value pair.
  # This method is atomic.
  #
  # @note Atomic methods taking a block do not allow the `self` instance
  #   to be used within the block. Doing so will cause a deadlock.
  # @return [self]
  # @yield for each key value pair in the map
  # @yieldparam key [Object]
  # @yieldparam value [Object]
  #
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/map.rb#271
  def each; end

  # Iterates over each key.
  # This method is atomic.
  #
  # @note Atomic methods taking a block do not allow the `self` instance
  #   to be used within the block. Doing so will cause a deadlock.
  # @return [self]
  # @yield for each key in the map
  # @yieldparam key [Object]
  #
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/map.rb#252
  def each_key; end

  # Iterates over each key value pair.
  # This method is atomic.
  #
  # @note Atomic methods taking a block do not allow the `self` instance
  #   to be used within the block. Doing so will cause a deadlock.
  # @return [self]
  # @yield for each key value pair in the map
  # @yieldparam key [Object]
  # @yieldparam value [Object]
  #
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/map.rb#271
  def each_pair; end

  # Iterates over each value.
  # This method is atomic.
  #
  # @note Atomic methods taking a block do not allow the `self` instance
  #   to be used within the block. Doing so will cause a deadlock.
  # @return [self]
  # @yield for each value in the map
  # @yieldparam value [Object]
  #
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/map.rb#261
  def each_value; end

  # Is map empty?
  #
  # @return [true, false]
  #
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/map.rb#288
  def empty?; end

  # Get a value with key, or default_value when key is absent,
  # or fail when no default_value is given.
  #
  # @note The "fetch-then-act" methods of `Map` are not atomic. `Map` is intended
  #   to be use as a concurrency primitive with strong happens-before
  #   guarantees. It is not intended to be used as a high-level abstraction
  #   supporting complex operations. All read and write operations are
  #   thread safe, but no guarantees are made regarding race conditions
  #   between the fetch operation and yielding to the block. Additionally,
  #   this method does not support recursion. This is due to internal
  #   constraints that are very unlikely to change in the near future.
  # @param key [Object]
  # @param default_value [Object]
  # @raise [KeyError] when key is missing and no default_value is provided
  # @return [Object] the value or default value
  # @yield default value for a key
  # @yieldparam key [Object]
  # @yieldreturn [Object] default value
  #
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/map.rb#180
  def fetch(key, default_value = T.unsafe(nil)); end

  # Fetch value with key, or store default value when key is absent,
  # or fail when no default_value is given. This is a two step operation,
  # therefore not atomic. The store can overwrite other concurrently
  # stored value.
  #
  # @param key [Object]
  # @param default_value [Object]
  # @return [Object] the value or default value
  # @yield default value for a key
  # @yieldparam key [Object]
  # @yieldreturn [Object] default value
  #
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/map.rb#202
  def fetch_or_store(key, default_value = T.unsafe(nil)); end

  # Get a value with key
  #
  # @param key [Object]
  # @return [Object] the value
  #
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/map.rb#137
  def get(key); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/map.rb#318
  def inspect; end

  # Find key of a value.
  #
  # @param value [Object]
  # @return [Object, nil] key or nil when not found
  #
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/map.rb#281
  def key(value); end

  # All keys
  #
  # @return [::Array<Object>] keys
  #
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/map.rb#233
  def keys; end

  # @raise [TypeError]
  #
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/map.rb#302
  def marshal_dump; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/map.rb#310
  def marshal_load(hash); end

  # Set a value with key
  #
  # @param key [Object]
  # @param value [Object]
  # @return [Object] the new value
  #
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/map.rb#155
  def put(key, value); end

  # Insert value into map with key if key is absent in one atomic step.
  #
  # @param key [Object]
  # @param value [Object]
  # @return [Object, nil] the previous value when key was present or nil when there was no key
  #
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/map.rb#212
  def put_if_absent(key, value); end

  # Is the value stored in the map. Iterates over all values.
  #
  # @param value [Object]
  # @return [true, false]
  #
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/map.rb#224
  def value?(value); end

  # All values
  #
  # @return [::Array<Object>] values
  #
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/map.rb#241
  def values; end

  private

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/map.rb#328
  def initialize_copy(other); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/map.rb#333
  def populate_from(hash); end

  # @raise [KeyError]
  #
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/map.rb#324
  def raise_fetch_no_key; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/map.rb#338
  def validate_options_hash!(options); end
end

# Various classes within allows for +nil+ values to be stored,
# so a special +NULL+ token is required to indicate the "nil-ness".
#
# source://concurrent-ruby//lib/concurrent-ruby/concurrent/constants.rb#6
Concurrent::NULL = T.let(T.unsafe(nil), Object)

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/utility/engine.rb#3
module Concurrent::Utility; end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/utility/engine.rb#6
module Concurrent::Utility::EngineDetector
  # @return [Boolean]
  #
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/utility/engine.rb#7
  def on_cruby?; end

  # @return [Boolean]
  #
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/utility/engine.rb#11
  def on_jruby?; end

  # @return [Boolean]
  #
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/utility/engine.rb#27
  def on_linux?; end

  # @return [Boolean]
  #
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/utility/engine.rb#23
  def on_osx?; end

  # @return [Boolean]
  #
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/utility/engine.rb#15
  def on_truffleruby?; end

  # @return [Boolean]
  #
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/utility/engine.rb#19
  def on_windows?; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/utility/engine.rb#31
  def ruby_version(version = T.unsafe(nil), comparison, major, minor, patch); end
end
